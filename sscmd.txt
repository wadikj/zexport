Simple Script - предназначен для сбоора данных в веб-страниц.
имеются комадны для доступа к элементам, ожидания, загрузки страниц
методика работы - оббежать несколько страниц, сложить данные в выходной
буфер, а потом записать его на диск
Если необходимо сделать что то сложное, то можно вызывть скрипт питона.

При работе из одного скрипта можно вызвать другие. Но при этом все скрипты
будут использовать один и тот же набор переменных и выходной буфер.

каждый скрипт содержит основное тело, начинающееся с первой строки. Также он может
содержать подпрограммы. Имя каждой подпрограммы начинается с @. Если необходимо
вызвать подпрограмму из того же файла, то просто указывается ее имя с
префиксом @. Если подпрограмма находится в другом файле, то необходимо указывать
ее полное имя - scr_name@proc_name

стуктура команды:
cmd=param, param, param,...
в зависимоти от команды, параметры могут и отсутствовать

Каждый элемент на странице имеет путь - от корневого в виде цепочки индексов
  элементов в списках родительских. Если путь 0 - это указание на элемент <body>
  текущей страницы, путь 0\0 - указание на путь первого дожернего у <body> и так
  далее. таким образом в рамках текущей страницы мы можем добраться до каждого
  элемента. Если указание пути начинается с \, то мы ищем путь от текущего
  элемента, или, если он задан, то от локального корня.

Элемент <body> страницы является коневым элементом, от которого ведется поиск
остальных элементов. Для передачи в вызываемые скрипы текущий элемент
передается как локальный корень.

Для переходов внутри скриптов используется относительная адресация, а не
абсолютная. Т.е. мы смещаемся относительно теущей строки на Х строк вверх или
вниз.


параметры и внутренние функции
FDlm = '|' - знасение этой переменной используется для разделения элементов
  при добавлении в Result
Result - текущая строка, в которую склабываются все извлеченные данные
FData - выходной буфер
SCR_DIR - текущий каталог скриптов
DATA_DIR - текущий каталог данных
FCurrent - текущий элемент HTML страницы (IHTMLElement)
GetLSData - функция по переданному параметру Value возвращает значение
  параметр      значение
  "" или .it    FCurrent.innerText
  .bb           FCurrent.beforeBegin
  .ab           FCurrent.afterBegin
  .be           FCurrent.beforeEnd
  .ae           FCurrent.afterEnd
  .ih           FCurrent.innerHTML
  .ot           FCurrent.outerText
  .oh           FCurrent.outerHTML
  .ti           текущее время
  .loc          URL, открытый на текущей активной веб-странице
  $xxx          $xxx рассматривается как имя переменной, возвр ее згначение
                или '', если переменной нет
  @ххх          ххх рассматривается как имя атрибута у FCurrent. возвращается
                значение атрибута с заданным именем или '', если атрибута нет
  если нет ничего из вышеперечисленного, то возвращается значение Value


Команды, используемые в скриптах

* - комментарий, в скриптах не используется
$xxx=Value - задает переменной с именем $ххх новое значение. Для получения
  значения используется GetLSData
wait - ожидает, пока браузер не перейдет в состояние READYSTATE_COMPLETE. Но с
    учетом того, что на станицах могут быть скрипты и дак далее. фактическое
    состояние браузера можетбыть другим
name=value - текущим элементом становится первый найденный с атрибутом name,
    равным value
attr=attr,value - текущему элементу FCurrent устанавливается атрибут с именем
    attr в значение value
id=value - текущим элементом становится элемент с аттрибутом id, равним value
click - выполняется нажатие на элемент FCurrent
path=value - текущим элементом становится элемент с указанным путем. Если путь
    начинается с \, то новый текущий элемент ищется от текущего LocalRoot, если
    он имеется, иначе от корневого.
idx=value - если текущий элемент IHTMLSelectElement, то его
    selectedIndex = value (value должно быть числом)
select - если текущий элемент - это IHTMLOptionElement, то делает его выбранным
location=value - задает у тек браузера новое местоположение. (фактически, переход
    по адресу value)
delay=value - ждет указаное количество миллисекунд, по умолчанию 3000
msg=value = отображает на экране сообщение, значение берется из GetLSData
submit - если текущий элемент является формой, то для нее выызвается метод
  SUBMIT
view -  выводит новую вкладку, в которой находится содержимое работы скрипта
foreach=scrname - для каждого элемента из списка FCurrent.Children выызвается
    скрипт scrname. Страница при этом не должна перегружаться.
execjs  - вроде не работает
setlr - текущий элемент становится локальным корнем
close - закрывает текущий браузер
test - выводит в лог список поддерживаемых интерфейсов у текущего элемента
exit - прерывает выполнение текущего скрипта
exec -  ? вроде должен вызвать выполнение джаваскрипта с заданным именем
event - должен у текущего элемента вызвать событие с указанным именем
log=value - выводит в лог значение value, или, если не указано, FResStr
addstr - добавляет к FResStr текущее значение с использованием тек разделителя '|'
scr - запускает скрипт с указанным именем. при этом текущий элемент становится
    локальным корнем для нового скрипта
getlr - делает локальный корень текущим элементом
savedata=value - сохраняет текущие данный в файл. имя файла может содержать имена
    переменных в квадратных скобках (подставляются их значения). После записи
    содержимое FData очищается.
savepage=value - сохраняет текущую страницу HTML в файл c именем value. имя
    файла может соlержать имена переменных в квадратных скобках.
    (подставляются их значения)
waitfor=value - ожидает, пока на странице не появится узел с путем value, или
  пока не пройдет 30 секунд
waitdiff=varname,path,lsdata - передается имя переменной, путь к узлу и что из
    узла брать. Ожидает, пока узел не появится и значение из него не будет
    совпадать с тем, что было в переданой переменной. после несовпадения в
    переменную записывается новое значение. Метод получения значения указывается
    в третьем параметре (GetLSData).
{[comboname] - задает занчение внутреннего поля FComboName
[forcombo=scrname] - пробегает по всем элементам комбовокса и для каждого из них
    делает его активным и вызывает указанный скрипт. в вызываемом скрипте надо
    производить действия, чтобы у комбобокса было вызывано событие OnChange (или
    то, что надо)}
saveres - сохраняет текущую строку FresStr в данных скрипта и очищает ее.
repeat=scr,varname,start - аналог foreach, но сохраняет номер элемента в varname,
    обработка данных начинается индекса start
    (Выполняет scr для каждого элемента FCurrent. Fcurrent должен быть коллекцией
    или у нео должно быть свойство children. Текущую сраницу нельзя менять)
for=path,varname,scr - проходит по всем дочерним элементам элемента из path.
    Индекс текущего элемента хранится в varname. Устойчив к изменению и
    перегрузкам текущей страницы. (каждый раз вначале итерации неявно
    выполняется команда path="path"+"\"+varname). При выполнении следует учесть
    времена на загрузку текущей страницы.
goback - команда браузеру GoBack
ifbreak=lsdata1, lsdata2,1|0 - сравнивает 2 параметра (GetLSData), и если они
    равны, то останавливает скрипт. Если 2 параметр равен 1, то остановка
    скрипта происходит при НЕРАВЕНСТВЕ параметров
goto=linedelta - производит переход на строку, индекс которой отличается от
    индекса текущей на linedelta. (в команде используется смещение относительно
    текущей строки, а не абсолютный адрес строки).
ifexist=linedelta,param - переход по смещению linedelta, если param существует
    или param начинается с "@", "$" или ".", то вызывается GetLSData, иначе
    param зрассматривается как path. Если param="", то берется текущий путь.
    Существование подразумевает, что элемент не равен "".
ifnexist=linedelta,param - то же, но переход происходит в случае если параметр
    не существует
if=linedelta,param1,oper,param2 - переход по смещению, если результат операции
    oper над param1 и param2 - истина. Param1,2 - добываются как GetLSDara,
    переход - см goto. Операции могут быть =,<,>,!(не равно),@(содержит),!@ (не
    содержит). все параметры рассматриваются как строки, сожержит - это значит,
    что параметр1 - является подстрокой параметра2
vload=fname,v1,v2,.. - сохраняет в файл с именем fname указанные переменные. Если
    список переменных не указан, то сохраняются все переменные. Если имя файла
    не указано, то используется стандартное ("vars"). По умолчанию файл
    сохраняется в каталоге скриптов. Переменные хранятся в виде "имя"="значение"
    построчно. Если переменная хранит многострочное значение, то требуется
    специальная обработка файла.
vload=fname,v1,v2,... - читает из файла с именем fname список значений переменных
    с указанными именами. Если имена переменныъх не заданы, то читает все
    значения. Если имя файла не указано, то используется стандартное "vars" в
    каталоге скриптов.
py_scr=scr,params - запуск скрипта питон с именем scr. Если не указано иначе,
    скрипт иется в втвлоге скриптов. Params - если есть, то это параметры для
    обрамляющих команд vsave и vload. (для передаыи параметров между simplescr
    и скриптом питона. питон должен прочитать файл vars, и при необходимости,
    изменить его).
gethead - запихивает в FData заголовок текущей html-страницы (то что находится
    в <head>).


[...] - если не нашлось в том, что выше, то ищем и выполняем внешнюю функцию
RegisterExternalFunction (ProcName:string;AProc:TInternalProc)- регистрирует
внешнюю функцию. В скриптах она доступна под именем ProcName
тип внешней функции
  TInternalProc = procedure (Sender:TSimpleScript) of object;

UnRegisterExternalFunction (ProcName:string); - отменяет регистрайию внешней
функции. После этого функция под именем ProcName в скриптах недоступна

Все выполняемые в данный момент скрипты разделяют переменные и данные.

IHTMLFrameBase
  property src:WideString read Get_src write Set_src;

 IHTMLFrameBase2
   property contentWindow:IHTMLWindow2 read Get_contentWindow;
   //добавить для сравнения то окно, в котором у нас текущий документ
IHTMLFrameElement2
       // height :
   property height:OleVariant read Get_height write Set_height;
    // width :
   property width:OleVariant read Get_width write Set_width;

IHTMLFrameElement3
    // contentDocument :
   property contentDocument:IDispatch read Get_contentDocument;
   property src:WideString read Get_src write Set_src;

 IHTMLIFrameElement2
       // height :
   property height:OleVariant read Get_height write Set_height;
    // width :
   property width:OleVariant read Get_width write Set_width;


IHTMLIFrameElement3
    property contentDocument:IDispatch read Get_contentDocument;
    // src :
   property src:WideString read Get_src write Set_src;
    // longDesc :
   property longDesc:WideString read Get_longDesc write Set_longDesc;
    // frameBorder :
   property frameBorder:WideString read Get_frameBorder write Set_frameBorder;
